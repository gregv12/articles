## Velocity Template
/*
 * Copyright (C) 2019 V12 Technology Ltd.
*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Server Side Public License, version 1,
 * as published by MongoDB, Inc.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Server Side License for more details.
 *
 * You should have received a copy of the Server Side Public License
 * along with this program.  If not, see 
 * <http://www.mongodb.com/licensing/server-side-public-license>.
 */
package ${package};
#foreach( $import in $imports)
import $import;
#end

/**
 * Utility class providing static helper methods to create mapping operations
 * in streams from a set of wrapped functions.
 *
 * This class is autogenerated from executing {@link StreamFunctionGenerator}
 *
 * @author Greg Higgins
 */
public class ${className}  {

#foreach( $FunctionInfo in $bifunctions)

    public static <T extends ${FunctionInfo.inputTypeReal}, S extends ${FunctionInfo.input1TypeReal}> SerializableBiFunction<T, S, ${FunctionInfo.returnType}> ${FunctionInfo.functionName}() {
        return ${FunctionInfo.invoke};
    }

    public static <T, S> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(SerializableFunction<T, ${FunctionInfo.inputType}> supplier1, SerializableFunction<S, ${FunctionInfo.input1Type}> supplier2) {
        return map(${FunctionInfo.functionName}(), arg(supplier1), arg(supplier2));
    }

    public static <T extends ${FunctionInfo.inputType}, S extends ${FunctionInfo.input1Type}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(SerializableSupplier<T> supplier1, SerializableSupplier<T> supplier2) {
        return map(${FunctionInfo.functionName}(), arg(supplier1), arg(supplier2));
    }

    public static <T extends ${FunctionInfo.inputType}, S extends ${FunctionInfo.input1Type}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(Argument<T> arg1, Argument<S> arg2) {
        return map(${FunctionInfo.functionName}(), arg1, arg2);
    }

    public static <T extends ${FunctionInfo.inputType}, S extends ${FunctionInfo.input1Type}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(Wrapper<T> wrapper1, Wrapper<S> wrapper2) {
        return map(${FunctionInfo.functionName}(), arg(wrapper1), arg(wrapper2));
    }

    public static <T extends ${FunctionInfo.inputType}, S extends ${FunctionInfo.input1Type}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(SerializableFunction<T, ${FunctionInfo.inputType}> supplier1, Wrapper<S> supplier2) {
        return map(subtract(), arg(supplier1), arg(supplier2));
    }
    
    public static <T extends ${FunctionInfo.inputType}, S extends ${FunctionInfo.input1Type}> Wrapper<${FunctionInfo.returnType}>  ${FunctionInfo.functionName}( Wrapper<T> supplier1, SerializableFunction<S, ${FunctionInfo.inputType}> supplier2) {
        return map(subtract(), arg(supplier1), arg(supplier2));
    }

#end

#foreach( $FunctionInfo in $functions)
    /**
     * Wrap {@link ${FunctionInfo.methodName} } function for use as a map operation in an existing
     * stream. {@link Wrapper#map(SerializableFunction) }
     * requires a {@link SerializableFunction} to map input values.
     *
     * @param <T> input to {@link ${FunctionInfo.methodName} }
     * @return {@link SerializableFunction} of {@link ${FunctionInfo.methodName} }
     */
    public static <T extends ${FunctionInfo.inputTypeReal}> SerializableFunction<T, ${FunctionInfo.returnType}> ${FunctionInfo.functionName}() {
        return ${FunctionInfo.invoke};
    }

    /**
     * Performs a {@link ${FunctionInfo.methodName}} function as a map operation on a stream.
     * The stream is automatically created by subscribing to the {@link Event}
     * and wrapping the supplier function with {@link Wrapper&lt;${FunctionInfo.inputType}&gt;}. 
     * The wrapper is the input to the mapping function. The mapped value is available as
     * a {@link Wrapper&lt;${FunctionInfo.returnType}&gt;} instance for further stream operations.
     *
     * @param <T> The input event stream
     * @param supplier The input value to the function {@link ${FunctionInfo.methodName}
     * @return {@link  Wrapper&lt;${FunctionInfo.returnType}&gt;} wrapping the result of {@link ${FunctionInfo.methodName}}
     */
    public static <T> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(SerializableFunction<T, ${FunctionInfo.inputType}> supplier) {
        return map(${FunctionInfo.functionName}(), arg(supplier));
    }

    public static <T extends ${FunctionInfo.inputType}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(Argument<T> arg) {
        return map(${FunctionInfo.functionName}(), arg);
    }

    /**
     * Performs a {@link ${FunctionInfo.methodName}} function as a map operation on a stream.
     * The stream is automatically created by wrapping the supplier instance function in a
     * {@link Wrapper&lt;${FunctionInfo.inputType}&gt;}, the wrapper is the input 
     * to the mapping function. The mapped value is available as
     * a {@link Wrapper&lt;${FunctionInfo.returnType}&gt;} instance for further stream operations.
     *
     * @param <T> The input type required by {@link ${FunctionInfo.methodName}}
     * @param supplier The wrapped instance supplying values to the function {@link ${FunctionInfo.methodName}
     * @return {@link  Wrapper&lt;${FunctionInfo.returnType}&gt;} wrapping the result of {@link ${FunctionInfo.methodName}}
     */
    public static <T extends ${FunctionInfo.inputType}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(SerializableSupplier<T> supplier) {
        return map(${FunctionInfo.functionName}(), arg(supplier));
    }

    public static <T, S extends ${FunctionInfo.inputType}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(Wrapper<T> wrapper, SerializableFunction<T, S> supplier) {
        return map(${FunctionInfo.functionName}(),  arg(wrapper, supplier));
    }

    public static <T extends ${FunctionInfo.inputType}> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(Wrapper<T> wrapper) {
        return map(${FunctionInfo.functionName}(),  arg(wrapper));
    }

#end

#foreach( $FunctionInfo in $consumers)
    /**
     * Wrap {@link ${FunctionInfo.methodName} } function for use as a map operation in an existing
     * stream. {@link Wrapper#map(SerializableFunction) }
     * requires a {@link SerializableFunction} to map input values.
     *
     * @param <T> input to {@link ${FunctionInfo.methodName} }
     * @return {@link SerializableFunction} of {@link ${FunctionInfo.methodName} }
     */
    public static <T> SerializableFunction<T, ${FunctionInfo.returnType}> ${FunctionInfo.functionName}() {
        return ${FunctionInfo.invoke};
    }

    /**
     * Performs a {@link ${FunctionInfo.methodName}} function as a map operation on a stream.
     * The stream is automatically created by subscribing to the {@link Event}
     * and wrapping the supplier function with {@link Wrapper&lt;T&gt;}. 
     * The wrapper is the input to the mapping function. The mapped value is available as
     * a {@link Wrapper&lt;${FunctionInfo.returnType}&gt;} instance for further stream operations.
     *
     * @param <T> The input event stream
     * @return {@link  Wrapper&lt;${FunctionInfo.returnType}&gt;} wrapping the result of {@link ${FunctionInfo.methodName}}
     */
    public static <T> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(Class<T> eventClass) {
        return select(eventClass).map(${FunctionInfo.functionName}());
    }

    /**
     * Performs a {@link ${FunctionInfo.methodName}} function as a map operation on a stream.
     * The stream is automatically created by wrapping the supplier instance function in a
     * {@link Wrapper&lt;T&gt;}, the wrapper is the input 
     * to the mapping function. The mapped value is available as
     * a {@link Wrapper&lt;${FunctionInfo.returnType}&gt;} instance for further stream operations.
     *
     * @param <T> The input type required by {@link ${FunctionInfo.methodName}}
     * @param supplier The wrapped instance supplying values to the function {@link ${FunctionInfo.methodName}
     * @return {@link  Wrapper&lt;${FunctionInfo.returnType}&gt;} wrapping the result of {@link ${FunctionInfo.methodName}}
     */
    public static <T> Wrapper<${FunctionInfo.returnType}> ${FunctionInfo.functionName}(T supplier) {
        return stream(supplier).map(${FunctionInfo.functionName}());
    }
#end


}

